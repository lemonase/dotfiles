# If not running interactively, don't do anything
case $- in
  *i*) ;;
  *) return;;
esac

# HISTORY OPTIONS
# ---------------
HISTSIZE= ;
HISTFILESIZE=
HISTCONTROL="ignoreboth:erasedups"
HISTTIMEFORMAT="%F %T  "

# SHELL OPTIONS
# -------------
shopt -s checkhash checkjobs checkwinsize 
shopt -s direxpand dirspell extglob globstar
shopt -s cmdhist histappend

# VARIABLES
# ---------
export EDITOR="/usr/bin/vim"
export VISUAL="/usr/bin/vim"
export PAGER="less"

export GH="https://github.com/lemonase"

# ALIASES
# -------
# common options
LS_OPTS="-F --color=auto"
GREP_OPTS="--color=auto"

# ls
alias l='ls ${LS_OPTS}'
alias ls='ls ${LS_OPTS}'
alias ll='ls -lsh ${LS_OPTS}'
alias la='ls -Alsh ${LS_OPTS}'
alias al='ls -A ${LS_OPTS}'
alias sl='ls -lsSh ${LS_OPTS}'
alias sal='ls -AlsSh ${LS_OPTS}'

# grep
alias grep='grep ${GREP_OPTS}'
alias fgrep='fgrep ${GREP_OPTS}'
alias egrep='egrep ${GREP_OPTS}'

# utility aliases
alias tree='tree -C'
alias treel='tree -C | less -R'
alias df='df -h'
alias lsmnt='mount | column -t'
alias mkdir='mkdir -p'

# git
alias g=git
alias groot='cd $(git rev-parse --show-toplevel 2> /dev/null || echo -n ".")'

# tmux
alias tmls='tmux ls'
alias tmlsc='tmux lsc'
alias tmks='tmux kill-session -t' # kill one session
alias tmka='tmux kill-server' # aka killall

# python venv
alias venvac='source venv/bin/activate'

# COLORS 
# ------
# color vars using tput or ANSI/VT100 Control sequences
if command -v "tput" > /dev/null 2>&1 ; then
  black="\[$(tput setaf 0)\]"
  red="\[$(tput setaf 1)\]"
  green="\[$(tput setaf 2)\]"
  yellow="\[$(tput setaf 3)\]"
  blue="\[$(tput setaf 4)\]"
  purple="\[$(tput setaf 5)\]"
  cyan="\[$(tput setaf 6)\]"
  white="\[$(tput setaf 7)\]"
  reset="\[$(tput sgr0)\]"
  bold="\[$(tput bold)\]"
else
  black="\[\033[0;30\]"
  red="\[\033[1;31\]"
  green="\[\033[1;32\]"
  yellow="\[\033[1;33\]"
  blue="\[\033[1;34\]"
  purple="\[\033[1;35\]"
  cyan="\[\033[1;36\]"
  white="\[\033[1;37\]"
  reset="\[\033[0m\]"
  bold="\[\033[1m\]"
fi

# FUNCTIONS
# ---------
# common commands improved
cll() { cd -P "$@" && ls -alshF; }
cls() { cd -P "$@" && ls; }
mkcd() { mkdir -p -- "$1" && cd "$1"; }
cdd() { [ -n "$1" ] && for i in $(seq 1 "$1"); do cd ..; done; }
touchx() { touch "$@" && chmod +x "$@"; }

# tmux
tm() {
  if [ "$#" -gt 0 ]; then
    tmux new-session -As "$1"
  else
    tmux new-session
  fi
}

tma() {
  if [ "$#" -gt 0 ]; then
    tmux attach-session -d -t "$1"
    if [ "$?" -ne 0 ]; then
      tmux new-session -As "$1"
    fi
  else
    tmux attach
  fi
}

# paths and files
pathappend() {
  # https://superuser.com/questions/39751/add-directory-to-path-if-its-not-already-there
  for ARG; do
    if [ -d "$ARG" ] && [[ ":$PATH:" != *":$ARG:"* ]]; then
      ABS_DIR="$(readlink -f "$ARG")"
      PATH="${PATH:+"$PATH:"}$ABS_DIR"
      echo "$ABS_DIR" added!
    else
      echo Invalid directory in "\"$*\""
    fi
  done
}

bkup() {
  # create backup file with date appended
  if [ -f "$1" ]; then
    cp "${1}" "${1}.bkup.$(date +'%F.%R')"
  fi
}

# hugo -- create and edit a new post
new-post() {
  postname=""
  if [ -z "$1" ]; then
    echo -n "Please enter a postname: "
    read -r postname
  else
    postname="$1"
  fi

  post_filename="$postname.md"
  blog_dir="$HOME/src/blog"
  local_url="http://localhost:1313/posts/$postname"

  hugo new -s "$blog_dir" "posts/$post_filename"
  hugo serve -s "$blog_dir" -D &> /dev/null &
  xdg-open "$local_url" &> /dev/null &
  vim "$blog_dir/content/posts/$post_filename" && kill %1
}

# git
lazygit() { git commit -a -m "$*" && git push; }
lg() { lazygit "$*"; }

# git prompt function
parse_git() {
  # ways to get branches
  # git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/(\1)/'
  # git rev-parse --abbrev-ref HEAD 2> /dev/null | sed -e 's/.*\/\(.*\)/\1/'

  BRANCH="$(git rev-parse --abbrev-ref HEAD 2> /dev/null)"
  STATUS="$(git status 2> /dev/null)"

  if [[ $? -ne 0 ]]; then return; else printf "$(tput sgr0)$(tput bold)%s" ":(${BRANCH})["; fi

  if echo "${STATUS}" | grep -c "nothing to commit" &> /dev/null; then printf "$(tput setaf 4)%s" "="; else printf ""; fi

  if echo "${STATUS}" | grep -c "renamed:"  &> /dev/null; then printf "$(tput setaf 1)%s" ">"; else printf ""; fi
  if echo "${STATUS}" | grep -c "deleted:"  &> /dev/null; then printf "$(tput setaf 1)%s" "-"; else printf ""; fi
  if echo "${STATUS}" | grep -c "new file:" &> /dev/null; then printf "$(tput setaf 2)%s" "+"; else printf ""; fi

  if echo "${STATUS}" | grep -c "branch is ahead:" &> /dev/null; then printf "$(tput setaf 3)%s" "!"; else printf ""; fi
  if echo "${STATUS}" | grep -c "Untracked files:" &> /dev/null; then printf "$(tput setaf 3)%s" "?"; else printf ""; fi
  if echo "${STATUS}" | grep -c "modified:"        &> /dev/null; then printf "$(tput setaf 3)%s" "*"; else printf ""; fi

  printf "$(tput setaf 7)%s" "]"
}

# PROMPTS
# -------
# start prompt string
PS1="${bold}"

# ***git prompts***
# PS1+="${blue}\w\[\$(parse_git)\] ${cyan}\\$ "
PS1+="${white}[\t] ${blue}\w\[\$(parse_git)\] ${green}\\$ "
# PS1+="${purple}\u${yellow}@${cyan}\h${white}:${blue}\w\[\$(parse_git)\]${yellow} \\$ "
# PS1+="\n${cyan}\u ${white}at ${yellow}\h ${white}in ${blue}\w ${white}on \[\$(parse_git)\]\n${yellow}\\$ "

# ***non git prompts***
# PS1+="${blue}\w ${yellow}\\$ "
# PS1+="${purple}\u${yellow}@${cyan}\h${white}:${blue}\w ${yellow}\\$ "

# ***non-color prompts***
# PS1="\w \\$ "
# PS1="[\u@\h:\w] \\$ "
# PS1="\u@\h:\w \\$ "

# end prompt string
PS1+="${reset}"

# BASH AUTOCOMPLETION
# -------------------
if ! shopt -oq posix; then
  if [ -f /usr/share/bash-completion/bash_completion ]; then
    source /usr/share/bash-completion/bash_completion
  elif [ -f /etc/bash_completion ]; then
    source /etc/bash_completion
  fi
fi

# LOCAL RC
# --------
[ -f "$HOME/.config/bashrc" ] && source "$HOME/.config/bashrc"

