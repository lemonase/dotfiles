# If not running interactively, don't do anything
case $- in
	*i*) ;;
	*) return;;
esac

#========== HISTORY OPTIONS ==========#
HISTSIZE= ;
HISTFILESIZE=
HISTCONTROL="ignoreboth:erasedups"
HISTTIMEFORMAT="%F %T  "

#========== SHELL OPTIONS ==========#
shopt -s checkhash checkjobs checkwinsize cmdhist direxpand dirspell extglob globstar histappend

#========== PROGRAM VARIABLES ==========#
export EDITOR="/usr/bin/vim"
export VISUAL="/usr/bin/vim"
export PAGER="less"

#========== ALIASES ==========#

# common options

LS_OPTS="-F --color=auto"
GREP_OPTS="--color=auto"

# ls 
alias l='ls ${LS_OPTS}'
alias ls='ls ${LS_OPTS}'
alias ll='ls -lsh ${LS_OPTS}'
alias la='ls -Alsh ${LS_OPTS}'

alias al='ls -A ${LS_OPTS}'
alias sl='ls -lsSh ${LS_OPTS}'
alias sal='ls -AlsSh ${LS_OPTS}'

# cd

alias cd..='cd ..'
alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'
alias ..2='cd ../..'
alias ..3='cd ../../..'
alias ..4='cd ../../../..'
alias ..5='cd ../../../../..'

# grep

alias grep='grep ${GREP_OPTS}'
alias fgrep='fgrep ${GREP_OPTS}'
alias egrep='egrep ${GREP_OPTS}'

# utility aliases

alias tree='tree -C'
alias treel='tree -C | less -R'
alias df='df -h'
alias lsmnt='mount | column -t'
alias mkdir='mkdir -pv'

# git

alias g=git
alias groot='cd $(git rev-parse --show-toplevel 2> /dev/null || echo -n ".")'

# tmux

alias tmls='tmux ls'
alias tmlsc='tmux lsc'
alias tmks='tmux kill-session -t' # kill one session
alias tmka='tmux kill-server' # aka killall

# python venv
alias venvac='source venv/bin/activate'

#========== FUNCTIONS ==========#

# common commands used together

cl() {
	builtin cd -P "$@" && ls -alshF
}

mkcd() {
	mkdir -p -- "$1" && cd "$1"
}

touchx() {
	touch "$@" && chmod +x "$@"
}

# git

lazygit() {
	git commit -a -m "$*" && git push
}

lg() {
	lazygit "$*"
}

# git prompt functions

parse_git() {
	# ways to get branches
	# git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/(\1)/'
	# git rev-parse --abbrev-ref HEAD 2> /dev/null | sed -e 's/.*\/\(.*\)/\1/'

	BRANCH="$(git rev-parse --abbrev-ref HEAD 2> /dev/null)"
	STATUS="$(git status 2> /dev/null)"

	if [[ $? -ne 0 ]]; then
		return
	else
		printf "\033[1;37m:(${BRANCH})["
	fi

	if echo "${STATUS}" | grep -c "nothing to commit"         &> /dev/null; then printf "\033[1;34m=\033[0m"; else printf ""; fi
	if echo "${STATUS}" | grep -c "renamed:"         &> /dev/null; then printf "\033[1;31m>\033[0m"; else printf ""; fi
	if echo "${STATUS}" | grep -c "deleted:"         &> /dev/null; then printf "\033[1;31m-\033[0m"; else printf ""; fi
	if echo "${STATUS}" | grep -c "new file:"       &> /dev/null; then printf "\033[1;32m+\033[0m"; else printf ""; fi

	if echo "${STATUS}" | grep -c "branch is ahead:" &> /dev/null; then printf "\033[1;33m!\033[0m"; else printf ""; fi
	if echo "${STATUS}" | grep -c "Untracked files:" &> /dev/null; then printf "\033[1;33m?\033[0m"; else printf ""; fi
	if echo "${STATUS}" | grep -c "modified:"        &> /dev/null; then printf "\033[1;33m*\033[0m"; else printf ""; fi

	printf "\033[1;37m]"
}

# tmux

tm() {
	if [ "$#" -gt 0 ]; then
		tmux new-session -As "$1"
	else
		tmux new-session
	fi
}

tma() {
	if [ "$#" -gt 0 ]; then
		tmux attach-session -d -t "$1"
		if [ "$?" -ne 0 ]; then
			tmux new-session -As "$1"
		fi
	else
		tmux attach
	fi
}

# paths and files

pathappend() {
	# https://superuser.com/questions/39751/add-directory-to-path-if-its-not-already-there
	for ARG; do
		if [ -d "$ARG" ] && [[ ":$PATH:" != *":$ARG:"* ]]; then
			ABS_DIR="$(readlink -f "$ARG")"
			PATH="${PATH:+"$PATH:"}$ABS_DIR"
			echo "$ABS_DIR" added!
		else
			echo Invalid directory in "\"$*\""
		fi
	done
}

bkup() {
	# create backup file with date appended
	if [ -f "$1" ]; then
		cp "${1}" "${1}.bkup.$(date +'%F.%R')"
	fi
}

#========== PROMPTS ==========#
# git prompts
# PS1="\[\033[1;34m\]\w\[\033[0m\]\$(parse_git) \[\033[1;36m\]\$\[\033[0m\] "
# PS1="\[\033[1;35m\]\u\[\033[1;33m\]@\[\033[1;36m\]\h\[\033[0m\]:\[\033[1;37:\[\033[1;34m\]\w\[\033[0m\]\$(parse_git)\[\033[0m\]\[\033[1;33m\]$ \[\033[0m\]"
# PS1="\[\033[1;36m\]\u \[\033[1;37m\]at \[\033[1;33m\]\h \[\033[1;37m\]in \[\033[1;34m\]\w \[\033[1;37m\]on \[\033[1;37m\]\$(parse_git)\n\[\033[1;37m\]\$ "

PS1="\[\033[1;34m\]\W\[\033[0m\]\$(parse_git) \[\033[1;35m\]\$\[\033[0m\] "
# PS1="\[\033[1;35m\]\u\[\033[1;33m\]@\[\033[1;36m\]\h\[\033[0m\]:\[\033[1;37:\[\033[1;34m\]\W\[\033[0m\]\$(parse_git)\[\033[0m\]\[\033[1;33m\]$ \[\033[0m\]"

# non git prompts
# PS1="\[\033[1;34m\]\w \[\033[1;33m\]\$ \[\033[0m\]"
# PS1="\[\033[1;35m\]\u\[\033[1;33m\]@\[\033[1;36m\]\h\[\033[0m\]:\[\033[1;37:\[\033[1;34m\]\w\[\033[0m\]\[\033[1;33m\]$ \[\033[0m\]"

# non color prompts
# PS1="\w \$ "
# PS1="[\u@\h:\w]$ "
# PS1="\u@\h:\w$ "

#========== BASH AUTOCOMPLETION ==========#
if ! shopt -oq posix; then
	if [ -f /usr/share/bash-completion/bash_completion ]; then
		. /usr/share/bash-completion/bash_completion
	elif [ -f /etc/bash_completion ]; then
		. /etc/bash_completion
	fi
fi

#========== COLORS REFERENCE ==========#
# COLORS according to (ANSI/VT100 Control sequences)
# https://misc.flogisoft.com/bash/tip_colors_and_formatting for examples

# \[\033[0;30m\]	BLACK		\[\033[1;30m\]		DARK GREY		
# \[\033[0;31m\]	RED			\[\033[1;31m\]		LIGHT RED			
# \[\033[0;32m\]	GREEN		\[\033[1;32m\]		LIGHT GREEN		
# \[\033[0;33m\]	BROWN		\[\033[1;33m\]		YELLOW		
# \[\033[0;34m\]	BLUE		\[\033[1;34m\]		LIGHT BLUE		
# \[\033[0;35m\]	PURPLE		\[\033[1;35m\]		LIGHT PURPLE		
# \[\033[0;36m\]	CYAN		\[\033[1;36m\]		LIGHT CYAN		
# \[\033[0;37m\]	LIGHT GREY	\[\033[1;37m\]		WHITE		

# \[\033[0m\]		RESET NORMAL
# \[\033[1m\]		RESET BOLD

